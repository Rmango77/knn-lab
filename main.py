import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

st.markdown("<h2 style='text-align: center; color: black;'>Исследование похожести при помощи метода k-ближайших соседей</h2>", unsafe_allow_html=True)

st.write("""Метод K-ближайших соседей – это алгоритм Машинного обучения (ML), который используют для решения задач [классификации](https://www.helenkapatsa.ru/klassifikatsiia/?ysclid=l7bs2eg18x683875799) и [регрессии](https://koroteev.site/text/ml1/?ysclid=l7bryn1t4520698227). Смысл данного метода очень хорошо раскрывает фраза «Скажи мне, кто твой друг, и я скажу, кто ты».""")

col1, col2, col3 = st.columns([1, 6, 1])
with col1:
    st.write("")

with col2:
    st.image("screensaver.png")

with col3:
    st.write("")

st.write("""Предполагается, что уже имеется какое-то количество объектов с точной классификацией (т.е. для каждого из них точно известно, какому классу он принадлежит). Нужно выработать правило, позволяющее отнести новый объект к одному из возможных классов (т.е. сами классы известны заранее).

В основе k-NN лежит следующее правило: объект считается принадлежащим тому классу, к которому относится большинство его ближайших соседей. Под «соседями» здесь понимаются объекты, близкие к исследуемому в том или ином смысле.

Заметим, что здесь необходимо уметь определять, насколько объекты близки друг к другу, т.е. уметь измерять «расстояние» между объектами. Это не обязательно евклидово расстояние. 
Это может быть мера близости объектов, например, по цвету, форме, вкусу, запаху, интересам (если речь идёт о формировании групп людей), особенностям поведения и т.д. Следовательно, для применения метода k-NN в пространстве признаков объектов должна быть введена некоторая метрика (т.е. функция расстояния).

Предполагается, что объекты с близкими значениями одних признаков будут близки и по другим признакам (т.е. относиться к одному и тому же классу).""")

st.markdown("<h2 style='text-align: left; color: black;'>Этапы разработки кейса</h2>", unsafe_allow_html=True)
st.image('tree-steps.png', width=700)

pipeline_bar = st.expander("Описание пайплайна лабораторной работы")
pipeline_bar.markdown(
    """
    \n**Этапы:**
    \n
    \n**1. Блок теории:**
    \nЗдесь студенту предлагается познакомиться с теоретической составляющей метода k-ближайших соседей. Понять кому и когда данный метод может быть полезен. Разобраться с основными метриками, позволяющими измерить расстояние между объектами.
    \n**2. Демонстрация метода:**
	\nВ данном блоке демонстрируется приминение метода k-ближайших соседей. Студенту предлагается ввести название фильма. После чего рекомендательная система, благодаря методу k-ближайших соседей, выдаст ему k-наиболее похожих, на введенный, фильмов. 
    \n**3. Задания на теорию:**
	\nВ этом блоке студент, основываясь на знаниях полученных в теоретическом блоке, должен выполнить ряд теоретических заданий
	\n**4. Расчетные задания:**
	\nЗдась студенту необходимо выполнить ряд расчетных заданий посвященных вычислению расстояния между объектами
    \n**6. Оформление микросервиса Streamlit, выгрузка на сервер:**
	\nПроводится сотрудником лаборатории, используется студентами РАНХиГС
    \nС использованием библиотеки [streamlit](https://docs.streamlit.io/library/get-started)
    """)

st.write("""Представим, что мы проводим классификацию объектов на два класса — красный или жёлтый. Нам дана некоторая обучающая выборка и целевой объект (серый):""")

col1, col2, col3 = st.columns([1, 6, 1])
with col1:
    st.write("")

with col2:
    st.image("knn.png")

with col3:
    st.write("")

st.write("""Мы хотим определить, к какому классу относится серый объект. Интуитивно очевидно, что он должен быть жёлтым, потому что все его соседи жёлтые. Эта интуиция и отражает суть метода KNN — классифицировать целевой объект, исходя из того, какие классы у объектов, которые максимально похожи на него.""")

st.write("""Данный пример, подводит нас непосредственно к самому алгоритму метода k-ближайших соседей:""")

st.write("""
1. Выберите число k, характеризующее количество соседей

2.Вычислите расстояние между всеми точками попарно. Отсортируйте получившийся набор расстояний от наименьшего к наибольшему. Затем выберите первые k записей.

3.Для задач классификации определите Моду – наиболее распространенную метку кластера.""")

st.markdown("<h6 style='text-align: left; color: black;'>Кому нужен метод k-ближайших соседей</h6>", unsafe_allow_html=True)
st.write("""
	
	1. _Юристы_ могут автоматизировать процесс поиска похожих судебных дел.
    
	2. _Аналитики данных_ могут использовать данный метод для поиска различных соответствий внутри данных.
    
    3. _Экономисты_ могут использовать данный метод при моделировании кредитных рисков.

	"""
)

st.write("""Для формализации понятия сходства вводится функция расстояния между объектами. Чем меньше расстояние между объектами, тем больше объекты похожи друг на друга. Метрические классификаторы опираются на гипотезу компактности, которая предполагает, что схожим объектам чаще соответствуют схожие ответы.""")

st.write("""Существует несколько математических метрик, позволяющие измерить расстояние между объектами:""")

st.write("""1. Евклидово расстояние.

Евклидово расстояние между точками a (x1, y1) и b (x2, y2) на двумерной плоскости:""")

col1, col2, col3 = st.columns([1, 6, 1])
with col1:
    st.write("")

with col2:
    st.image("euclidean.png")

with col3:
    st.write("")
    
st.write("""2. Косинусное расстояние. 

В геометрии угол косинуса может использоваться для измерения разницы между двумя направлениями вектора, а в машинном обучении эта концепция используется для измерения разницы между векторами выборки.

Формула косинуса угла между вектором A (x1, y1) и вектором B (x2, y2) в двумерном пространстве:""")

col1, col2, col3 = st.columns([1, 6, 1])
with col1:
    st.write("")

with col2:
    st.image("cosine.png")

with col3:
    st.write("")
    
st.write("""Диапазон угла косинуса составляет [-1,1]. Чем больше косинус, тем меньше угол между двумя векторами, и чем меньше косинус, тем больше угол между двумя векторами. Когда направления двух векторов совпадают, косинус принимает максимальное значение 1, а когда направления двух векторов полностью противоположны, косинус принимает минимальное значение -1.""")
    
st.write("""3. Расстояние манхэттена. 

Манхэттенское расстояние между двумя точками a (x1, y1) и b (x2, y2) в двумерной плоскости:""")

col1, col2, col3 = st.columns([1, 6, 1])
with col1:
    st.write("")

with col2:
    st.image("manhattan.png")

with col3:
    st.write("")
    
st.markdown("<h6 style='text-align: center; color: black;'>Построение рекомендательной системы при помощи метода k-ближайших соседей</h6>", unsafe_allow_html=True)

st.write("""Посмотрим как при помощи метода k-ближайших соседей найти k наиболее похожих фильмов""")

#credits = pd.read_csv("tmdb_5000_credits.csv")
movies = pd.read_csv("movie.csv")

st.dataframe(movies.drop(['Жанр', 'Ключевые слова'], axis=1).head())

click = st.selectbox("Посмотреть на график распределения рейтингов фильмов?", ["", "Да", "В другой раз"])

if click == "Да":
    col1, col2, col3 = st.columns([1, 6, 1])
    with col1:
        st.write("")

    with col2:
        st.image("movie-frequency.png")

    with col3:
        st.write("")
    
    st.write("""В реальной жизни, только небольшая часть фильмов имеет большое число отзывов. Большое количество, менее известных фильмов, могут вообще не иметь рейтингов.""")

input_film = st.text_input(label="Введите название фильма")

if input_film not in movies['Оригинальное название'].values:
    st.write("""Такого фильма нет в каталоге. Проверьте правильность написания.""")
    
elif input_film != "":
    #credits.columns = ['Номер фильма', 'title', 'cast', 'crew']
    #movies = movies.merge(credits, on='Номер фильма')

    movies['Описание'] = movies['Описание'].fillna('')

    def create_soup(x):
        return ''.join(x['Ключевые слова'])+ '' + ''.join(x['Жанр']) + '' + ''.join(x['Описание'])
    movies['soup'] = movies.apply(create_soup, axis=1)

    tfidf = TfidfVectorizer()
    tfidf_matrix = tfidf.fit_transform(movies['soup'])
    tfidf_matrix.shape

    cosin_sim = linear_kernel(tfidf_matrix, tfidf_matrix)

    indecs = pd.Series(movies.index, index=movies['Оригинальное название']).drop_duplicates()

    def get_recomendation(title, cosin_sim=cosin_sim):
        idx = indecs[title]

        sim_scores = list(enumerate(cosin_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
        sim_scores = sim_scores[1:11]

        movie_indices = [i[0] for i in sim_scores]
        return movies['Оригинальное название'].iloc[movie_indices]

    recomendations = get_recomendation(input_film, cosin_sim)
    st.write(recomendations)

st.markdown("<h6 style='text-align: center; color: black;'>Задание для лабораторной работы</h6>", unsafe_allow_html=True)

click0 = st.selectbox("Для каких типов задач применим метод k-ближайших соседей", ["", "Классификация", "Регрессия", "Классификация и регрессия"])

click1 = st.selectbox("Посчитайте Евклидово расстояние между точками с координатами a(1, 5, 19) и b(23, 14, 8). Ответ округлите до ближайшего целого чтсла", ["", "26", "25", "18"])

click2 = st.selectbox("Посчитайте Косинусное расстояние между векторами a(3, 45, 7) и b(2, 54, 13)", ["", "0.45", "-0.87", "0.99"])

click3 = st.selectbox("Исходя из Косинусного расстояния, полученного в предыдущем вопросе, определите направление векторов", ["", "Сонаправленные", "Противоположно направленные", "Перпендикулярные"])

click4 = st.selectbox("Почему плохо использовать маленькое значение k", ["", "Процент пользователей, которые совершили целевое действие по отношению к общему числу посетителей", "Метрика, показывающая как часто покупают определенный товар", "Метрика в интернет-маркетинге. Определяется как отношение числа кликов на баннер или рекламное объявление к числу показов"])

click5 = st.selectbox("В чем оснавной минус метода k-ближайших соседей", ["", "Сложно выбрать необходимое значение для параметра k", "Данный метод не интерпретируемый", "Для того чтобы  определить, к какому классу относится целевой объект необходимо посчитать расстояние до всех объектов. Что займет определенное время при большом объеме выборки"])

count = 0
if click0 == "Классификация и регрессия":
    count += 1
    
if click1 == "26":
    count += 1

if click2 == "0.99":
    count += 1

if click3 == "Сонаправленные":
    count += 1
    
if click4 == "Техника проверки гипотез. Позволяет оценить, как изменение сервиса или продукта повлияет на пользователей":
    count += 1
    
if click5 == "Для того чтобы  определить, к какому классу относится целевой объект необходимо посчитать расстояние до всех объектов. Что займет определенное время при большом объеме выборки":
    count += 1

if count >= 5:
    st.markdown("<h6 style='text-align: center; color: black;'>Лабораторная работа cдана!</h6>", unsafe_allow_html=True)
else:
    st.markdown("<h6 style='text-align: center; color: black;'>Лабораторная работа пока не сдана</h6>", unsafe_allow_html=True)

